// IOS -> mex -> food-pax-api -> offers /user 10

// checkout page -> food-api-api -> food-cart -> offers

// stackable offer 20%

// omega -> offers discount/condition/time

// UT/QA/gandalf test/

// PM prd spec -> eng spec services / FE / offers single -> mul

// single -> multiple

// prd test -> QA mex/user ->
// grabx userID
// city/ country/ geo hash
// percentage /

// cache / spot instance / GC ballast
// 10G

// mex list    user -> mex list
// food-pax-api user 10 mex

// driver list / foot bike car

// foot 3  10 600
// bike 2  8  1000
// car 5	  10 2000

// (10*3 + 8*2 + 10*5)10 eta

// pickup
// 1 user 1 mex -> all transport type

// dropOff
// eta dis

// food-pax-api-> 20mex / user food-eta -> 10 mex/user all tt

// user city -> tt
// food-eta user / all mexs / 1 tt -> geo

// G M P

// -------






func formatMenu(list []*Menu) []*Menu {
	res := []*Menu{}
	m := map[int64]*Menu{}
	for _, v := range list {
		ptr := v
		if ptr.ParentID == 0 {
			res = append(res, ptr)
		}
		m[ptr.ID] = ptr
	}
	for _, v := range list {
		node := v
		if node.ParentID == 0 {
			continue
		}
		parent := m[node.ParentID]
		parent.ChildMenu = append(parent.ChildMenu, node)
	}
	return res
}

type Menu struct {
	ID        int64
	Name      string
	ParentID  int64
	ChildMenu []*Menu
}


func a() string {

  url := "https://postman-echo.com/get?test=a"
  method := "GET"

  client := &http.Client {}
  req, err := http.NewRequest(method, url, nil)

  if err != nil {
    fmt.Println(err)
    return
  }
  req.Header.Add("Cookie", "sails.sid=s%3AIkiiupYvZRksCRTVmsX5_0GBxv0hojfy.zKKWEjzmSrZh%2BBCuxCYi%2BClzhVmoAdVaZ8URViZJf2g")

  res, err := client.Do(req)
  if err != nil {
    fmt.Println(err)
    return
  }
  defer res.Body.Close()

  body, err := ioutil.ReadAll(res.Body)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(string(body))
}

// list := []*Menu{
	// 	{
	// 		ID:        100,
	// 		Name:      "aaa",
	// 		ParentID:  0,
	// 		ChildMenu: nil,
	// 	},
	// 	{
	// 		ID:        101,
	// 		Name:      "bbb",
	// 		ParentID:  100,
	// 		ChildMenu: nil,
	// 	},
	// 	{
	// 		ID:        102,
	// 		Name:      "ccc",
	// 		ParentID:  100,
	// 		ChildMenu: nil,
	// 	},
	// }
	// res := formatMenu(list)
	// fmt.Println(len(res), res[0], len(res[0].ChildMenu), res[0].ChildMenu[1])

	wg := &sync.WaitGroup{}
	ch := make(chan map[string]string, 3)
	wg.Add(3)
	go func(){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
		wg.Done()
	}()
	go func(){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
		wg.Done()
	}()
	go func(){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
		wg.Done()
	}()

	wg.Wait()
	close(ch)

	// res := map[string]string{}
	// for i, v := range ch {
		
	// }

	ctx := context.Background()
	ctx, cancelFunc := context.WithCancel(ctx)
	defer cancelFunc()

	go func(subctx context.Context){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
	}(ctx)
	go func(subctx context.Context){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
	}(ctx)
	go func(subctx context.Context){
		resStr := a()
		res := map[string]string{
			"a": resStr,
		}
		ch <- res
	}(ctx)
	res := <- ch
	return res


raft 是写和读都在主节点，与读写分离的主节点写从节点读并不相同。

重构上线时新代码和旧代码做检验？如果是非幂等操作的话
首先可以检验两者操作是否相同，但新代码不会实际去执行
或者做数据回放，读取数据后检验两者操作结果数据是否一致

redis怎么实现读写分离

