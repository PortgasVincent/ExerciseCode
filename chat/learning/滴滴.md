go 哪些类型是传递引用，传递的是指针还是值？
go只有值传递，但是类型分为值类型和指针类型（引用类型

slice是怎么实现的，内部用到了那些结构？
struct{*pArray, len, cap}

go routine 和主线程之间是怎样进行变量传递？Panic会影响到主函数吗？channel内部结构
channel/共享全局变量/context, 会影响到，需要给可能panic的go routine加recover，主程序加recover捕捉不到

协程为什么小，可以达到KB？
协程只存在于用户空间，而线程可以存在于内核空间，可以被CPU调度，包含了更多信息
goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行。
一个标准的线程由线程ID,当前指令指针（PC）、寄存器集合和堆栈组成。它是由操作系统控制，包含更多资源和信息，所以需要存储空间大
线程中的代码是在用户态运行，而线程的调度是在内核态。用户态程序执行好好的，突然由于以上因素，暂停原线程堆栈，坠入内核态，由cpu做线程切换

mysql怎样实现隔离级别？MVCC不是乐观锁吧
通过MVCC和表锁行锁间隙锁等悲观锁。MVCC是乐观机制，但不是乐观锁
乐观锁：在读写事务，在真正的提交之前，不加读/写锁，而是先看一下数据的版本/时间戳，等到真正提交的时候再看一下版本/时间戳，如果两次相同，说明别人期间没有对数据进行过修改，那么就可以放心提交；如果遇到冲突，则需要回退。
MVCC不会回退

当前读和快照读的区别？
快照读，通过readView
当前读：通过行锁和间隙锁

redis缓存过期机制？除了LRU呢，还有一种 
https://cloud.tencent.com/developer/article/1643921
redis过期策略：
1.定时过期：每个有过期时间的key都设一个定时器，key到期清除
2.惰性过期：只有当访问时才判断key是否过期，过期则清除
3.定期过期：每隔一段时间，扫描清除并清除过期key
内存淘汰策略:
no-eviction：当内存不足以容纳新写入数据时，新写入操作会报错。
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

redis持久化机制？日志文件过大会怎么处理，RDB用的是一个线程还是用别的线程？
使用rewirte机制，rewrite机制现在达到一定的条件redis会自动触发
其具体的流程就是：
1，redis主进程建立一个子进程
2，子进程根据当前内存的数据，构建一个新的日志，写入一个新的AOF文件中
3，这段时间内，redis接收到的client的修改操作，都会在内存中新起一个日志文件去进入，并同步到旧的AOF文件中
4，当子进程完成了任务，redis就会把新的日志文件追加到新的AOF文件中
5，使用新的AOF文件替换旧的AOF文件
-----------------------------------

redis 文件特别大 redis日志文件过大？
https://www.cnblogs.com/WeaRang/p/14435827.html
https://blog.51cto.com/u_16099265/6367836

redis的线程机制和IO机制？
https://blog.csdn.net/skye_fly/article/details/119711953
线程：
  主进程中的主线程：负责读、写、删除操作，以及数据更新后的写AOF日志，写完日志再返回请求
  主进程中的子线程：负责数据的延迟删除
  子进程中的子线程：负责RDB以及主从同步的子线程

redis hash扩表是怎么做的，会不会因为复制太多影响使用，旧表数据是怎样同步到新表的？
索引计数器redisidx为0表示rehash开始，每当有CRUD操作时，除了执行指定操作外，还会将旧表【redisidx索引上】所有键值对同步到新hash表
如果没有请求会不会复制？不会


